import { writeFileSync, existsSync, mkdirSync } from 'node:fs';
import { SitemapStream, streamToPromise } from 'sitemap';
import { resolve } from 'node:path';
import format from 'xml-formatter';

function resolveOptions(userOptions) {
  return Object.assign(
    {
      hostname: "http://localhost/",
      routes: [],
      exclude: [],
      filename: "sitemap",
      dest: "public",
      changefreq: "daily",
      priority: 1,
      lastmod: /* @__PURE__ */ new Date(),
      readable: false,
      nuxtStyle: false,
      allowRobots: true
    },
    userOptions
  );
}

function ensurePrefix(prefix, str) {
  if (!str.startsWith(prefix))
    return prefix + str;
  return str;
}

const dynamicRouteRE = /\[.+\]/;
const nuxtDynamicRouteRE = /_[\s\S]*/;
function isDynamicRoute(routePath, nuxtStyle) {
  if (!routePath)
    return false;
  return nuxtStyle ? nuxtDynamicRouteRE.test(routePath) : dynamicRouteRE.test(routePath);
}
function ensureSuffix(suffix, str) {
  if (!str.endsWith(suffix))
    return str + suffix;
  return str;
}
function removeMaybeSuffix(suffix, str) {
  if (!str.endsWith(suffix))
    return str;
  return str.slice(0, -suffix.length);
}

function getSitemapLinks(options) {
  const hostname = options.hostname;
  const routes = flatRoutes([...options.routes.values()]);
  return routes.filter((pageRoute) => !isDynamicRoute(pageRoute.component, options.nuxtStyle) || typeof pageRoute === "string").filter((pageRoute) => !options.exclude.includes(pageRoute.path) && !options.exclude.some((rx) => rx instanceof RegExp && rx.test(pageRoute.path))).map((pageRoute) => {
    const url = `${removeMaybeSuffix("/", hostname)}${typeof pageRoute === "string" ? pageRoute : pageRoute.path}`;
    const route = {
      url,
      changefreq: options.changefreq,
      priority: options.priority,
      lastmod: options.lastmod
    };
    if (options.i18n) {
      const languages = options.i18n.languages.map((str) => {
        var _a;
        return {
          lang: str,
          url: str === ((_a = options.i18n) == null ? void 0 : _a.defaultLanguage) ? hostname : `${removeMaybeSuffix("/", hostname)}${ensurePrefix("/", str)}`
        };
      });
      return Object.assign(route, { links: options.i18n.defaultLanguage ? [...languages, { lang: "x-default", hostname }] : languages });
    }
    return route;
  });
}
function flatRoutes(routes) {
  const flatRoutes2 = /* @__PURE__ */ new Set();
  const getFlatRoutes = (routes2, prefix = "") => {
    prefix = prefix.replace(/\/$/g, "");
    for (const route of routes2) {
      if (typeof route === "string") {
        flatRoutes2.add({
          component: void 0,
          path: route
        });
      } else {
        let path = route.path;
        if (route.path) {
          path = prefix && !route.path.startsWith("/") ? `${prefix}/${route.path}` : route.path;
          flatRoutes2.add({
            component: route.component,
            path
          });
        }
        if (Array.isArray(route.children))
          getFlatRoutes(route.children, path);
      }
    }
  };
  getFlatRoutes(routes);
  return [...flatRoutes2];
}
function getDestPath(dest) {
  return ensurePrefix("./", dest);
}
function getResolvedPath(filename, extension, dest) {
  const filenameWithExtension = ensureSuffix(extension, filename);
  return resolve(`${getDestPath(dest)}/${filenameWithExtension}`);
}
function writeXmlFile(resolvedPath, str, options) {
  writeFileSync(resolvedPath, options.readable ? format(str) : str);
}
function writeRobotFile(resolvedPath, options) {
  const str = "User-agent: *\n".concat(`${options.allowRobots ? "Allow" : "Disallow"}: /

`).concat(`Sitemap: ${getFinalSitemapPath(options)}`);
  writeFileSync(resolvedPath, str);
}
function getFinalSitemapPath(options) {
  return `${ensureSuffix("/", options.hostname)}${ensureSuffix(".xml", options.filename)}`;
}

function generateSitemap(options) {
  const resolvedOptions = resolveOptions(options);
  const RESOLVED_PATH = getResolvedPath(resolvedOptions.filename, ".xml", resolvedOptions.dest);
  const RESOLVED_ROBOT_PATH = getResolvedPath("robots", ".txt", resolvedOptions.dest);
  if (!resolvedOptions.routes.length)
    return;
  if (!existsSync(getDestPath(resolvedOptions.dest)))
    mkdirSync(getDestPath(resolvedOptions.dest));
  const stream = new SitemapStream();
  getSitemapLinks(resolvedOptions).forEach((item) => stream.write(item));
  streamToPromise(stream).then((sitemap) => {
    writeXmlFile(RESOLVED_PATH, sitemap.toString("utf-8"), resolvedOptions);
  });
  stream.end();
  writeRobotFile(RESOLVED_ROBOT_PATH, resolvedOptions);
}

export { generateSitemap as default };
